# Lab2 实现步骤与思考

## 1. 实验目标
在 Lab1 的基础上，实现功能更丰富的控制台输出系统，包括：
1.  **格式化输出**: 实现标准 C 库风格的 `printf` 和 `sprintf` 函数。
2.  **控制台增强**: 支持清屏、光标移动、清除行以及彩色输出。

## 2. 实现步骤

### 步骤 1: 基础驱动复用
- **文件**: `kernel/uart.c`
- **内容**: 直接复用 Lab1 的 UART 驱动，作为底层的字符输出通道。

### 步骤 2: 格式化输出核心 (`printf.c`)
- **文件**: `kernel/printf.c`
- **关键技术**: 可变参数列表 (`<stdarg.h>`)。
- **功能实现**:
  - **`print_number`**: 辅助函数，将整数转换为指定进制（10或16）的字符串并输出。
  - **`printf`**:
    - 解析格式字符串 `fmt`。
    - 遇到 `%` 时，根据后续字符 (`d`, `x`, `s`, `c`, `%`) 决定如何处理参数。
    - 使用 `va_arg` 从栈中获取参数。
  - **`sprintf`**: 类似于 `printf`，但将结果写入字符缓冲区 `buf` 而不是串口。

### 步骤 3: 控制台增强功能 (`console.c`)
- **文件**: `kernel/console.c`
- **核心机制**: ANSI 转义序列 (ANSI Escape Codes)。
- **功能实现**:
  - **`console_putc`**: 封装 `uart_putc`，未来可扩展处理特殊字符（如退格键 `\b`）。
  - **ANSI 控制**:
    - **清屏 (`clear_screen`)**: 发送 `\033[2J` (清除屏幕) 和 `\033[H` (光标归位)。
    - **光标移动 (`goto_xy`)**: 发送 `\033[y;xH`，其中 `y` 和 `x` 是坐标。
    - **清除行 (`clear_line`)**: 发送 `\033[K` (清除从光标到行末的内容)。
  - **彩色输出 (`printf_color`)**:
    - 在输出内容前发送颜色代码 `\033[3?m` (例如 `\033[31m` 为红色)。
    - 输出内容后发送重置代码 `\033[0m` 恢复默认颜色。

### 步骤 4: 测试验证 (`start.c`)
- **文件**: `kernel/start.c`
- **内容**:
  - `test_printf_basic()`: 测试整数、负数、十六进制、字符串、字符的输出。
  - `test_printf_edge_cases()`: 测试最大/最小整数、空指针等边界情况。
  - `test_console_features()`: 演示清屏、指定位置输出彩色文本等高级功能。

## 3. 相关思考

### 可变参数 (Variadic Arguments)
C 语言通过 `stdarg.h` 提供对可变参数的支持。在 RISC-V (以及大多数架构) 中，函数参数通常通过寄存器和栈传递。`va_start` 宏初始化一个指针（`va_list`），指向第一个可变参数的位置。`va_arg` 根据指定的类型（如 `int`）从当前位置读取数据，并移动指针到下一个参数。这使得 `printf` 能够处理数量不定的参数。

### ANSI 转义序列 (ANSI Escape Codes)
控制台（如 QEMU 的串口输出或 Linux 终端）不仅仅显示字符，还能解释特定的字节序列作为命令。这些序列通常以 `ESC` (ASCII 27, 十六进制 0x1B, C 语言写作 `\033`) 开头，后跟 `[`。例如，`\033[31m` 告诉终端“接下来的字符用红色显示”。这种机制使得我们无需图形显卡驱动，仅通过串口就能实现简单的富文本界面。

### 模块化设计
本实验将逻辑分为三层：
1.  **硬件层 (`uart.c`)**: 负责字节的物理发送。
2.  **抽象层 (`console.c`)**: 负责终端控制逻辑（颜色、光标）。
3.  **应用层 (`printf.c`)**: 负责数据的格式化。
这种分层设计使得代码结构清晰，易于维护和扩展。例如，如果更换了硬件（如 VGA 显卡），只需重写底层的 `putc`，上层的 `printf` 逻辑无需改动。
